//! Multiplicative inverses of integers in Montgomery form with a modulus set at runtime.

use super::{MontyForm, MontyParams};
use crate::{
    modular::BernsteinYangInverter, traits::Invert, ConstCtOption, Inverter, Odd,
    PrecomputeInverter, PrecomputeInverterWithAdjuster, Uint,
};
use core::fmt;
use subtle::CtOption;

impl<const SAT_LIMBS: usize, const UNSAT_LIMBS: usize> MontyForm<SAT_LIMBS>
where
    Odd<Uint<SAT_LIMBS>>: PrecomputeInverter<
        Inverter = BernsteinYangInverter<SAT_LIMBS, UNSAT_LIMBS>,
        Output = Uint<SAT_LIMBS>,
    >,
{
    /// Computes `self^-1` representing the multiplicative inverse of `self`.
    /// I.e. `self * self^-1 = 1`.
    /// If the number was invertible, the second element of the tuple is the truthy value,
    /// otherwise it is the falsy value (in which case the first element's value is unspecified).
    pub const fn inv(&self) -> ConstCtOption<Self> {
        let inverter = <Odd<Uint<SAT_LIMBS>> as PrecomputeInverter>::Inverter::new(
            &self.params.modulus,
            &self.params.r2,
        );

        let maybe_inverse = inverter.inv(&self.montgomery_form);
        let (inverse, inverse_is_some) = maybe_inverse.components_ref();

        let ret = Self {
            montgomery_form: *inverse,
            params: self.params,
        };

        ConstCtOption::new(ret, inverse_is_some)
    }
}

impl<const SAT_LIMBS: usize, const UNSAT_LIMBS: usize> Invert for MontyForm<SAT_LIMBS>
where
    Odd<Uint<SAT_LIMBS>>: PrecomputeInverter<
        Inverter = BernsteinYangInverter<SAT_LIMBS, UNSAT_LIMBS>,
        Output = Uint<SAT_LIMBS>,
    >,
{
    type Output = CtOption<Self>;

    fn invert(&self) -> Self::Output {
        self.inv().into()
    }
}

impl<const LIMBS: usize> PrecomputeInverter for MontyParams<LIMBS>
where
    Odd<Uint<LIMBS>>:
        PrecomputeInverter<Output = Uint<LIMBS>> + PrecomputeInverterWithAdjuster<Uint<LIMBS>>,
{
    type Inverter = MontyFormInverter<LIMBS>;
    type Output = MontyForm<LIMBS>;

    fn precompute_inverter(&self) -> MontyFormInverter<LIMBS> {
        MontyFormInverter {
            inverter: self.modulus.precompute_inverter_with_adjuster(&self.r2),
            params: *self,
        }
    }
}

/// Bernstein-Yang inverter which inverts [`MontyForm`] types.
pub struct MontyFormInverter<const LIMBS: usize>
where
    Odd<Uint<LIMBS>>: PrecomputeInverter<Output = Uint<LIMBS>>,
{
    inverter: <Odd<Uint<LIMBS>> as PrecomputeInverter>::Inverter,
    params: MontyParams<LIMBS>,
}

impl<const LIMBS: usize> Inverter for MontyFormInverter<LIMBS>
where
    Odd<Uint<LIMBS>>: PrecomputeInverter<Output = Uint<LIMBS>>,
{
    type Output = MontyForm<LIMBS>;

    fn invert(&self, value: &MontyForm<LIMBS>) -> CtOption<Self::Output> {
        debug_assert_eq!(self.params, value.params);

        self.inverter
            .invert(&value.montgomery_form)
            .map(|montgomery_form| MontyForm {
                montgomery_form,
                params: value.params,
            })
    }
}

impl<const SAT_LIMBS: usize, const UNSAT_LIMBS: usize> fmt::Debug for MontyFormInverter<SAT_LIMBS>
where
    Odd<Uint<SAT_LIMBS>>: PrecomputeInverter<
        Inverter = BernsteinYangInverter<SAT_LIMBS, UNSAT_LIMBS>,
        Output = Uint<SAT_LIMBS>,
    >,
{
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("MontyFormInverter")
            .field("modulus", &self.inverter.modulus)
            .finish()
    }
}

#[cfg(test)]
mod tests {
    use super::{MontyForm, MontyParams};
    use crate::{Invert, Inverter, Odd, PrecomputeInverter, U256};

    fn params() -> MontyParams<{ U256::LIMBS }> {
        MontyParams::new_vartime(Odd::<U256>::from_be_hex(
            "15477BCCEFE197328255BFA79A1217899016D927EF460F4FF404029D24FA4409",
        ))
    }

    #[test]
    fn test_self_inverse() {
        let params = params();
        let x =
            U256::from_be_hex("77117F1273373C26C700D076B3F780074D03339F56DD0EFB60E7F58441FD3685");
        let x_mod = MontyForm::new(&x, params);

        let inv = x_mod.invert().unwrap();
        let res = x_mod * inv;

        assert_eq!(res.retrieve(), U256::ONE);
    }

    #[test]
    fn test_self_inverse_precomuted() {
        let params = params();
        let x =
            U256::from_be_hex("77117F1273373C26C700D076B3F780074D03339F56DD0EFB60E7F58441FD3685");
        let x_mod = MontyForm::new(&x, params);

        let inverter = params.precompute_inverter();
        let inv = inverter.invert(&x_mod).unwrap();
        let res = x_mod * inv;

        assert_eq!(res.retrieve(), U256::ONE);
    }

    /// Test to illustrate a potential problem with the Bernstein&Yang code to
    /// invert numbers in Montgomery form. The specific parameters shown here
    /// come from intermittent test failures of [homomorphic_mul] in the
    /// Synedrion signining library (i.e. parameters are generated with an
    /// unseeded CSPRNG).
    ///
    /// For convenience, after this test follows a commented out version of the
    /// same that passes with crypto-bigint v0.5.5.
    ///
    /// Run the test with `cargo t inversion_v06_vs_v055`.
    ///
    /// [homomorphic_mul]: https://github.com/dvdplm/synedrion/blob/520e3246e6032a100db64eef47b3dee62cd7c055/synedrion/src/paillier/encryption.rs#L518
    #[test]
    fn inversion_v06_vs_v055() {
        use crate::{Limb, U2048};

        let params = MontyParams {
            modulus: Odd::new(U2048::from_be_hex("5DC56576A9F077F2FD05CC35DD0B1060857CD5A44011891ED05D8C56359A9302FC9FB1D6B2FF411FAC318009C519FB7D883ACF327C2FC1181642B7A076C7DB244AB265D20605AA55EB04B5F5100B961A684033BD4E98A45DFD2AAD4B13625808FF3C947BC3712CE8D2A5688579F08B5B523B9C6EC3361535379620F49E94C85508A6E0D264A284E3F6B3C54447D5DB9A421D1FBE2A1F59FFF92D1D9F68985E51C316CA027B4E6D9AAEED0D9F41DF77CFF021BF8F7A2E55E1F2B80859C466686305671C615757BA9712513A92764F399B486723549976024BEFF7A9484C40F5E765904E3477E1B6849468D513C26997D2A9BD038511C98E48FAE3493EC6A7FE49")).unwrap(),
            one: U2048::from_be_hex("44753512AC1F101A05F4679445E9DF3EF50654B77FDCEDC25F44E75394CAD9FA06C09C529A017DC0A79CFFEC75CC0904EF8A619B07A07DCFD37A90BF127049B76A9B345BF3F4AB5429F69415DFE8D3CB2F7F988562CEB74405AAA569D93B4FEE0186D708791DA62E5AB52EF50C1EE9495B88C7227993D59590D3BE16C2D66F55EEB23E5B36BAF63812987577705448CB7BC5C083ABC14C000DA5C4C12ECF435C79D26BFB096324CAA225E4C17C4110601FBC80E10BA3543C1A8FEF4C77332F39F531C73D51508AD1DB5D8ADB13618CC96F31B956CD13FB682010AD6F677E143134DF6397103C92F6D72E55D87B2CD05AAC85F8F5DC6CE36E0A396D8272B0036E"),
            r2: U2048::from_be_hex("3ECCFA8643CBBC3E03764FE8F9FFFE05DB6018B71A743939857318AE945CE4BBA0306A61719CA20FCE1910BD2A97BB34358334E776F7B12CB6289844D690D3B2DD95B84BD461BAB76C1544177307F2AB4FD55A14A9680CD1CBD777D24E534117CC2902BEB690BA620A7EDA562D9BF424512F36CAE3C4F77B5F89044A2725E44ACB1140CF2E7E3CADF9454685A2D9713EEE9A96D00EAC1089828DDE989090C255A3A59BB5BFC13713F987FA6593ADF0A1BEB15FB292D113CF7D12214EB971ABA43C1F876398D647D2E16F8AE0833B08D435DE7BACE60AB3CE021A8DD76CD2D0499AA69999D7F903DB04699F914106A1B704908D0F8380F4457248320D210AD120"),
            r3: U2048::from_be_hex("1046AA244A33A93BD07B563B4D087C8992640A2E008BF50A9C6F206F532A11FE591BD54971C105FEB67EE6AD19B00DF67505C8701526707A46834B43B7785E10CBE653EA83F7574C3703D4D5F3BEF68AF1F743008DD87DFBB3FA63D4DED4FD51EE1401FC160134755E399C7D81C5406D93E1CCF0A8AE42DD9E1E7ACF2EBEFA47B5CEA6D93DB4F63737FCC8294FD0D09445D3189C8A9CBC5FC3B58B65C2A41CEE9D3BEFB17FFEF1A595C8488765A3C5606EEE6EC983F177A0917EA711F235B75FC041D5D4462E59470D974D5FFD2F62C9343D7063F6093A58699B80AD3C59531673E8A8A6E725CBF5166ACC893E94F76A249AD90CFC6ACC9963B0AC2CA3419557"),
            mod_neg_inv: Limb(0x1A5316810A17AC07)
        };

        let a_number = MontyForm {
            montgomery_form: U2048::from_be_hex("38A5363CDDEFB1E9EE7CF941A8C90F8AC9ADBE88B829D4E82837EA944627B06C74099EB61442EC90D425536E5DC6B9244FF5115083D321E8B961243169FCB667E74667054EED5A839E2D1D5D16A1D24C202F3D9154874FB23103F0DC2A19AEE4DFDB97FB12325854B829E9BA191542A94B7FB10EDD2CCD50A5F03CECC16AA5FCCAB51F54651B8E9AAD2E3E3EE7BBF4EB613FF19AD0D7BB8FBA8854962A92BB7DA34511A1E5EB0CE02686B5F8A3E6B5CE148534B3D63A666429B80CB49D49416BD93D7BC99B9890FF908035349BBDDDEE047B472AE61CDE3357D8381A3E16FED1981C286CC54918DEE6ADE4EBB136C0F2E7F5AEF4608D80486C317025C34EE711"),
            params
        };
        let inverted = a_number.invert();

        // This is what v0.5.5 outputs using the same inputs.
        let expected_inv = MontyForm {
            montgomery_form: U2048::from_be_hex("2CA53822D62E244A0EA0545549CDE8118F50FC38C18B462E0B408ABF14D7082041178C7BE85BB28657F036BB9A8B45E6AD0FF4791061E6D79079F7E070729032A3DA57512EB130C1F83E11139669C08501643E985CF337697F20EE6F4611A551140E0E48C9EC68274E7F485D8FD766E1D697B946A60CAA315F5439241529A0042765322ADE388D1CC7C93D93AA1F5D7551AE115C05E5E9CBAD2C42C0F10B1294C7D08CD566A413AD1C0E161F1ACA21C6E300E0BA17B9FD2440384D0D674302C01F2C98BAA54A2E9532AFBF286B4ADBF73EFD64608CAEB886C3B21A53C0B199CBA489805BB92781D3BD2203C51D34198A3DBF364931EE948362B176DC7E231659"),
            params
        };
        assert!(bool::from(inverted.is_some()));
        assert_eq!(inverted.unwrap(), expected_inv);
    }

    // Version of the above test using v0.5.5:
    // #[test]
    // fn inverson_v0.6v_v0.5.5() {
    //     use crate::U2048;

    //     let params = DynResidueParams {
    //         modulus: U2048::from_be_hex("5DC56576A9F077F2FD05CC35DD0B1060857CD5A44011891ED05D8C56359A9302FC9FB1D6B2FF411FAC318009C519FB7D883ACF327C2FC1181642B7A076C7DB244AB265D20605AA55EB04B5F5100B961A684033BD4E98A45DFD2AAD4B13625808FF3C947BC3712CE8D2A5688579F08B5B523B9C6EC3361535379620F49E94C85508A6E0D264A284E3F6B3C54447D5DB9A421D1FBE2A1F59FFF92D1D9F68985E51C316CA027B4E6D9AAEED0D9F41DF77CFF021BF8F7A2E55E1F2B80859C466686305671C615757BA9712513A92764F399B486723549976024BEFF7A9484C40F5E765904E3477E1B6849468D513C26997D2A9BD038511C98E48FAE3493EC6A7FE49"),
    //         r: U2048::from_be_hex("44753512AC1F101A05F4679445E9DF3EF50654B77FDCEDC25F44E75394CAD9FA06C09C529A017DC0A79CFFEC75CC0904EF8A619B07A07DCFD37A90BF127049B76A9B345BF3F4AB5429F69415DFE8D3CB2F7F988562CEB74405AAA569D93B4FEE0186D708791DA62E5AB52EF50C1EE9495B88C7227993D59590D3BE16C2D66F55EEB23E5B36BAF63812987577705448CB7BC5C083ABC14C000DA5C4C12ECF435C79D26BFB096324CAA225E4C17C4110601FBC80E10BA3543C1A8FEF4C77332F39F531C73D51508AD1DB5D8ADB13618CC96F31B956CD13FB682010AD6F677E143134DF6397103C92F6D72E55D87B2CD05AAC85F8F5DC6CE36E0A396D8272B0036E"),
    //         r2: U2048::from_be_hex("3ECCFA8643CBBC3E03764FE8F9FFFE05DB6018B71A743939857318AE945CE4BBA0306A61719CA20FCE1910BD2A97BB34358334E776F7B12CB6289844D690D3B2DD95B84BD461BAB76C1544177307F2AB4FD55A14A9680CD1CBD777D24E534117CC2902BEB690BA620A7EDA562D9BF424512F36CAE3C4F77B5F89044A2725E44ACB1140CF2E7E3CADF9454685A2D9713EEE9A96D00EAC1089828DDE989090C255A3A59BB5BFC13713F987FA6593ADF0A1BEB15FB292D113CF7D12214EB971ABA43C1F876398D647D2E16F8AE0833B08D435DE7BACE60AB3CE021A8DD76CD2D0499AA69999D7F903DB04699F914106A1B704908D0F8380F4457248320D210AD120"),
    //         r3: U2048::from_be_hex("1046AA244A33A93BD07B563B4D087C8992640A2E008BF50A9C6F206F532A11FE591BD54971C105FEB67EE6AD19B00DF67505C8701526707A46834B43B7785E10CBE653EA83F7574C3703D4D5F3BEF68AF1F743008DD87DFBB3FA63D4DED4FD51EE1401FC160134755E399C7D81C5406D93E1CCF0A8AE42DD9E1E7ACF2EBEFA47B5CEA6D93DB4F63737FCC8294FD0D09445D3189C8A9CBC5FC3B58B65C2A41CEE9D3BEFB17FFEF1A595C8488765A3C5606EEE6EC983F177A0917EA711F235B75FC041D5D4462E59470D974D5FFD2F62C9343D7063F6093A58699B80AD3C59531673E8A8A6E725CBF5166ACC893E94F76A249AD90CFC6ACC9963B0AC2CA3419557"),
    //         mod_neg_inv: Limb(0x1A5316810A17AC07)
    //     };

    //     let a_number = DynResidue {
    //         montgomery_form: U2048::from_be_hex("38A5363CDDEFB1E9EE7CF941A8C90F8AC9ADBE88B829D4E82837EA944627B06C74099EB61442EC90D425536E5DC6B9244FF5115083D321E8B961243169FCB667E74667054EED5A839E2D1D5D16A1D24C202F3D9154874FB23103F0DC2A19AEE4DFDB97FB12325854B829E9BA191542A94B7FB10EDD2CCD50A5F03CECC16AA5FCCAB51F54651B8E9AAD2E3E3EE7BBF4EB613FF19AD0D7BB8FBA8854962A92BB7DA34511A1E5EB0CE02686B5F8A3E6B5CE148534B3D63A666429B80CB49D49416BD93D7BC99B9890FF908035349BBDDDEE047B472AE61CDE3357D8381A3E16FED1981C286CC54918DEE6ADE4EBB136C0F2E7F5AEF4608D80486C317025C34EE711"),
    //         residue_params: params.clone()
    //     };
    //     let (inverted, choice) = a_number.invert();

    //     let expected_inv = DynResidue {
    //         montgomery_form: U2048::from_be_hex("2CA53822D62E244A0EA0545549CDE8118F50FC38C18B462E0B408ABF14D7082041178C7BE85BB28657F036BB9A8B45E6AD0FF4791061E6D79079F7E070729032A3DA57512EB130C1F83E11139669C08501643E985CF337697F20EE6F4611A551140E0E48C9EC68274E7F485D8FD766E1D697B946A60CAA315F5439241529A0042765322ADE388D1CC7C93D93AA1F5D7551AE115C05E5E9CBAD2C42C0F10B1294C7D08CD566A413AD1C0E161F1ACA21C6E300E0BA17B9FD2440384D0D674302C01F2C98BAA54A2E9532AFBF286B4ADBF73EFD64608CAEB886C3B21A53C0B199CBA489805BB92781D3BD2203C51D34198A3DBF364931EE948362B176DC7E231659"),
    //         residue_params: params,
    //     };
    //     assert!(choice.is_true_vartime());
    //     assert_eq!(inverted, expected_inv);
    // }
}
